
cli admin-partitions {
    update-partition Common
}
cli script /Common/f5.iapp.1.5.2.cli {
#  Initialization proc for all templates.
#  Parameters "start" and "stop" or "end".
proc iapp_template { action } {
    switch $action {
        start {
            catch { tmsh::modify sys scriptd log-level debug }
            set ::clock_clicks [clock clicks]
            puts "\nStarting iApp $tmsh::app_template_name [clock format \
                [clock seconds] -format {%m/%d/%Y %T}]\n"
            tmsh::log info "Starting iApp template $tmsh::app_template_name"
        }
        stop -
        end {
            if { [info exists ::substa_debug] } {
                puts $::substa_debug
            }
            puts "\nEnding iApp $tmsh::app_template_name [clock format \
                [clock seconds] -format {%m/%d/%Y %T}]\nRun time [expr \
                { ([clock clicks] - $::clock_clicks) / 1000 }] msec\n"
            tmsh::log info "Ending iApp template $tmsh::app_template_name"
        }
    }
    set ::HTTP_CONTENT_TYPES { application/(css\|css-stylesheet\|doc\|excel\|javascript\|json\|lotus123\|mdb\|mpp\|msaccess\|msexcel\|ms-excel\|mspowerpoint\|ms-powerpoint\|msproject\|msword\|ms-word\|photoshop\|postscript\|powerpoint\|ps\|psd\|quarkexpress\|rtf\|txt\|visio\|vnd\\.excel\|vnd\\.msaccess\|vnd\\.ms-access\|vnd\\.msexcel\|vnd\\.ms-excel\|vnd\\.mspowerpoint\|vnd\\.ms-powerpoint\|vnd\\.ms-pps\|vnd\\.ms-project\|vnd\\.msword\|vnd\\.ms-word\|vnd\\.ms-works\|vnd\\.ms-works-db\|vnd\\.powerpoint\|vnd\\.visio\|vnd\\.wap\\.cmlscriptc\|vnd\\.wap\\.wmlc\|vnd\\.wap\\.xhtml\\+xml\|vnd\\.word\|vsd\|winword\|wks\|word\|x-excel\|xhtml\\+xml\|x-java-jnlp-file\|x-javascript\|x-json\|x-lotus123\|xls\|x-mdb\|xml\|x-mscardfile\|x-msclip\|x-msexcel\|x-ms-excel\|x-mspowerpoint\|x-msproject\|x-ms-project\|x-msword\|x-msworks-db\|x-msworks-wps\|x-photoshop\|x-postscript\|x-powerpoint\|x-ps\|x-quark-express\|x-rtf\|x-vermeer-rpc\|x-visio\|x-vsd\|x-wks\|x-word\|x-xls\|x-xml) image/(photoshop\|psd\|x-photoshop\|x-vsd) text/(css\|html\|javascript\|json\|plain\|postscript\|richtext\|rtf\|vnd\\.wap\\.wml\|vnd\\.wap\\.wmlscript\|wap\|wml\|x-component\|xml\|x-vcalendar\|x-vcard) }
}

proc iapp_is { args } {
    set up_var [lindex $args 0]
    upvar $up_var var
    if { [info exists var] } {
        foreach val [lrange $args 1 end] {
            if { [subst $var] eq $val } {
                return 1
            }
        }
    }
    return 0
}

proc iapp_substa { args } {
    upvar substa_in  argx \
          substa_out rval
    set   argx $args

    # check the explicit value first.
    # multiple layers of variable substitution requires multiple subst.
    # error occurs here if any of the substituted variables do not exist
    # valid wildcard (*) array entries will fail here first.
    uplevel {
        append ::substa_debug "\n$substa_in"
        if { [info exists [set substa_in]] } {
            set substa_out [subst $$substa_in]
            set substa_out [subst $substa_out]
        } else {
            # since explicit value did not exist, try a wildcard value.
            # substitute "*" as the array key and repeat.
            set substa_tmp [split $substa_in "()"]
            set substa_in "[lindex $substa_tmp 0](*)"
            append ::substa_debug "*"
            if { [info exists [set substa_in]] } {
                set substa_out [subst $$substa_in]
                set substa_out [subst $substa_out]
            } else {
                error "substa \"$substa_in\" array value not found"
            }
        }
    }
    return $rval
}

proc iapp_conf { args } {

    # Return value $object_name is set to the first word in $arg that
    # contains an underscore, since the position of the object name in
    # tmsh syntax is not consistent.
    set args [join $args]
    set object_name [lindex $args [lsearch -glob $args "*_*"]]

    # Global array ::tmsh_history persists between calls to iapp_conf
    # in order to suppress duplicate commands.
    if { ![info exists ::tmsh_history($args)] } {
        set ::tmsh_history($args) 1
        iapp_debug $args
        switch -exact -- [string range $args 0 5] {
            create { tmsh::create [string range $args 7 end] }
            modify { tmsh::modify [string range $args 7 end] }
            delete { tmsh::delete [string range $args 7 end] }
            default { error "iapp_conf illegal parameter" }
        }
    }
    return $object_name
}

proc iapp_make_safe_password { password } {
    return [string map { \' \\\' \" \\\" \{ \\\{ \} \\\} \; \\\; \| \\\| \# \\\# \  \\\  \\ \\\\ } $password]
}

proc iapp_pull { loc items_list } {
    upvar $items_list items
    if { [set item [lindex $items $loc]] != "" } {
        set items [lreplace $items $loc $loc]
    }
    return $item
}

proc iapp_process_flags { flags_array args_list } {
    upvar $flags_array flags
    upvar $args_list args

    if { [set dubdash [lsearch $args "--"]] != -1 } {
        set args [lreplace $args $dubdash $dubdash];
    } else {
        set dubdash end
    }

    foreach flag [array names flags] {
        while { [set ptr [lsearch [lrange $args 0 $dubdash] $flag]] != -1 } {
            set args [lreplace $args $ptr $ptr];

            # we want to run the code in the flags_array at the calling
            # proc's level so that the variables that it sets up are
            # available there.
            set access_var [format "$%s(%s)" $flags_array $flag]
            set command [subst -nocommands { set ptr $ptr ; subst $access_var }]

            uplevel 1 $command
        }
    }
    return $args
}

proc iapp_tmos_version { args } {
    set cversion [tmsh::version]
    if { $cversion eq "" } {
        tmsh::log err "unable to determine TMOS version"
        error "unable to determine TMOS version"
    }

    # if no op+version was specified, just return the version
    if { $args eq "" } { return $cversion }
    if { [llength $args] > 2 } {
        error "Too many arguments"
    }

    set op [lindex $args 0]; # operator
    set NOTFOUND -1
    # constrain to valid operators - adding more is fine as long as
    # they are supported by [expr] (and makes sense)
    if { [lsearch -exact { < > <= >= == != } $op] == $NOTFOUND } {
        tmsh::log err "illegal operator: $op"
        error "illegal operator: $op"
    }

    set tversion [lindex $args 1]; # target version
    # one or two decimal digits, optionally followed by 0-2 complete groups of
    # dots followed by one or two decimal digits with nothing before or after
    set regex {^\d{1,2}(\.\d{1,2}){0,2}$}
    if { ! [regexp -- $regex $tversion] } {
        tmsh::log err "cannot parse version from: $tversion"
        error "cannot parse version from: $tversion"
    }

    # p=>prefix, c=>current, t=>target
    foreach p { c t } {
        # extract major/minor/point components
        scan [set [set p]version] "%d.%d.%d" [set p]mjr [set p]mnr [set p]pnt
        # ensure that these are each set to at least 0
        foreach level { mjr mnr pnt } {
            if { ! [info exists [set p]${level}] } { set [set p]${level} 0 }
        }
        # turn them into one big number that we can compare
        # leave room in-between just to be safe
        set [set p]num [expr {
            [set [set p]mjr]*1000000 +
            [set [set p]mnr]*10000 +
            [set [set p]pnt]*100
        }]
    }
    # a simple numeric comparison is all that is needed at this point
    return [eval expr $cnum $op $tnum ]
}

proc iapp_safe_display { args } {
    # strings sent to APL must be truncated to 65535 bytes, see BZ435592
    if { [string length [set [set args]]] > 65535 } {
        set last_newline [string last "\n" [set [set args]] 65500]
        return "[string range [set [set args]] 0 $last_newline]Error: Too many items for display"
    } else {
        return [set [set args]]
    }
}

proc iapp_get_items { args } {

    # Set default values.
    set error_msg  "iapp_get_items $args:"
    set do_binary  0
    set nocomplain 0
    set items      ""
    set join_char  "\n"
    set recursive  "recursive"
    set com_dir    "/Common"
    set loc_dir    "[tmsh::pwd]"

    # Set up flag-related work.
    array set flags  {
        -exists      { [set do_binary 1] }
        -nocomplain  { [set nocomplain 1] }
        -list        { [set join_char " "] }
        -norecursive { [set recursive ""] }
        -local       { [set com_dir   ""] }
        -dir         { [set loc_dir      [iapp_pull $ptr args]] }
        -filter      { [set filter_field [iapp_pull $ptr args]] \
                       [set filter_op    [iapp_pull $ptr args]] \
                       [set filter_value [iapp_pull $ptr args]] }
    }
    iapp_process_flags flags args

    # Get system object names in all requested directories.
    set save_dir [tmsh::pwd]
    foreach dir [lsort -unique "$com_dir $loc_dir"] {
        tmsh::cd $dir
        set tmsh_rval [catch {
            foreach obj [tmsh::get_config $args $recursive] {

                if { [info exists filter_field] } {
                    if { $filter_field eq "NAME" } {
                        set val [tmsh::get_name $obj]
                    } else {
                        # If get_field_value throws error, assume "none" value
                        if { [catch {
                            set val [tmsh::get_field_value $obj $filter_field]
                            # strip quotes per BZ442531
                            set val [string map {\" ""} $val]
                        }]} { set val none }
                    }
                    # Non-Tcl operators =~ and !~ added for extra flexibility
                    if { $filter_op eq "=~" } {
                        set filter "\[regexp \"$filter_value\" \"$val\"\]"
                    } elseif { $filter_op eq "!~" } {
                        set filter "!\[regexp \"$filter_value\" \"$val\"\]"
                    } else {
                        set filter "\\\"$val\\\" $filter_op \\\"$filter_value\\\""
                    }
                    # If filter fails, skip to next object
                    if { ![eval expr $filter] } {
                        continue
                    }
                }
                # string map catches /Common added by ltm profile ntlm,
                # which is unlike all other ltm profile return values.
                lappend items $dir/[string map {/Common/ ""} [tmsh::get_name $obj]]
            }
        } err ]
    }
    tmsh::cd $save_dir

    # array keys: $do_binary,$tmsh_rval,$nocomplain. Do not insert whitespace.
    array set rval {
        0,0,0 {[join $items $join_char]}
        0,0,1 {[join $items $join_char]}
        0,1,0 {[error "$error_msg $err"]}
        0,1,1 {}
        1,0,0 {[llength $items]}
        1,0,1 {[llength $items]}
        1,1,0 {0}
        1,1,1 {0}
    }

    return [subst $rval($do_binary,$tmsh_rval,$nocomplain)]
}

proc iapp_get_provisioned { args } {

    array set lnum {
        none      0
        minimum   1
        nominal   2
        dedicated 3
    }

    # Set defaults.
    set required minimum
    set do_binary 1

    # Set up flag-related work.
    array set flags  {
        -is          { [set required [iapp_pull $ptr args]] }
        -level       { [set do_binary 0] }
    }
    iapp_process_flags flags args
    if { [llength $args] > 1 } {
        error "Too many arguments"
    }

    # If checking for AM provisioning on TMOS < 11.4,
    # check for WAM provisioning instead.
    if { $args eq "am" && [iapp_tmos_version < 11.4] } {
        set args "wam"
    }

    # Get the provisioning level. If blank, assume none.
    # Proc only checks 1 module at a time, so only 1 object is returned.
    if { [catch {
        set obj [tmsh::get_config sys provision $args]
        set level [tmsh::get_field_value [lindex $obj 0] level]
    }]} { set level none }

    if { $do_binary } {
        return [expr { $lnum($level) >= $lnum($required) }]
    } else {
        return $level
    }
}

proc iapp_get_user { args } {

    # Set defaults.
    set do_role 0
    set do_binary 0

    # Set up flag-related work.
    array set flags  {
        -is_admin    { [set do_binary 1] }
    }
    iapp_process_flags flags args
    if { [llength $args] > 1 } {
        error "Too many arguments"
    }

    # Show user auth was introduced in v11.6
    set user "unknown"
    catch {
        set user [tmsh::show auth user field-fmt]
    } err
    if { $do_binary } {
        return [expr { $user == "unknown"
        || [string first "role " $user] == -1
        || [string first "role admin" $user] != -1
        || [string first "role resource-admin" $user] != -1 }]
    } else {
        return $user
    }
}

proc iapp_destination { args } {
    # Set defaults. Flag actions may overwrite defaults later.
    set route_domain    0
    set do_mask         0
    set port            0

    # Set up flag-based actions.
    array set flags  {
        -route_domain { [set route_domain [iapp_pull $ptr args]] }
        -mask         { [set do_mask 1] }
        -length       { [set cidr_bits [iapp_pull $ptr args]] }
    }

    if { [llength [set non_switches [iapp_process_flags flags args]]] > 2 } {
        error "Too many arguments"
    }
    if { [llength $non_switches] == 2 } { set port [lindex $non_switches 1] }
    set addr [lindex $non_switches 0]


    # Detect a CIDR mask and pull it off the addr string
    if { [set loc [string first "/" $addr end-4]] != -1 } {
        set cidr_bits [string range $addr [expr {$loc + 1}] end]
        set addr [string range $addr 0 [expr {$loc - 1}]]
    }

    # Pull the route-domain off the addr string, but only use it as the
    # route domain if it wasn't overridden by -route_domain flag.
    if { [string first "%" $addr] != -1 } {
        if { $route_domain == 0 } {
            # route-domain is still default, so use value from addr string
            set route_domain [lindex [split $addr "%"] 1]
        }
        set addr [lindex [split $addr "%"] 0]
    }

    if { $do_mask } {

        # Define the delta between ipv4 and ipv6.
        # length: ipv4 mask is 32 bits, ipv6 is 128 bits.
        # group: ipv4 is grouped in octets, ipv6 as 16 bit words.
        # format: ipv4 is decimal notation, ipv6 is hex.
        # format1 also has the delimiter, format2 does not.
        array set v {
            0,length  32
            0,group   8
            0,format1 d.
            0,format2 d
            1,length  128
            1,group   16
            1,format1 .4x:
            1,format2 .4x
        }
        set is_ipv6 [string match "*:*:*" $addr]

        # Soften result of an illegal -length parameter.
        if { ![info exists cidr_bits] || $cidr_bits > $v($is_ipv6,length) } {
            set cidr_bits $v($is_ipv6,length)
        } elseif { $cidr_bits < 0 } {
            set cidr_bits 0
        }

        # Loop on the full length of the mask: 32 bits for ipv4, 128 for ipv6
        for { set octet 0; set i 0 } { $i < $v($is_ipv6,length) } { incr i } {

           # Take a break at intervals to save the grouping and add delimiter.
           # Interval is 8 bits for ipv4 and 16 bits for ipv6.
           if { $i && ![expr {$i % $v($is_ipv6,group)}] } {

               # Add the grouping and delimiter to the mask, then reset.
               append mask [format %$v($is_ipv6,format1) $octet]
               set octet 0
           }
           # Shift the prior bits left by multiplying by 2.
           # Then add the current bit, which is 1 if part of the mask, 0 if not.
           # Current bit is part of the mask if $i < number of bits in the mask.
           set octet [expr { 2 * $octet + ($i < $cidr_bits) }]
        }
        # Add the final grouping, then return the finished mask.
        set ret_val [format $mask%$v($is_ipv6,format2) $octet]

    } else {

        # calculate a destination
        # the route domain might be a name and we need a number.
        if { ![string is integer $route_domain] } {
            set route_domains [tmsh::get_config "/ net route-domain $route_domain"]
            if { [llength $route_domains] != 1 } {
                error "no such route domain: $route_domain"
            }
            # since we have already determined that the list is 1 long,
            # this explicit reference to element 0 is safe
            set route_domain [tmsh::get_field_value [lindex $route_domains 0] "id"]
        }

        set route_domain [expr { $route_domain == 0 ? "" : "%$route_domain" }]

        # 0 and * represent wildcard port assignments in the GUI,
        # but TMSH requires the string 'any' to specify a wildcard.
        if { $port == 0 || $port == "*" } {
            set port any
        }

        # Build the final destination. Use ":" for node names even if ipv6.
        set is_ipv6_literal [string match "*:*:*" $addr]
        set addr_delimiter  [expr { $is_ipv6_literal ? "." : ":" }]
        set ret_val ${addr}${route_domain}${addr_delimiter}${port}
    }
    return $ret_val
}

proc iapp_pool_members { args } {

    # Set defaults.
    array set fields {
        address          addr
        port             port
        port-secure      port_secure
        connection-limit connection_limit
        priority-group   priority
        ratio            ratio
    }
    set route_domain ""
    set port_override -1
    set aaa_domain 0
    set aaa_priority -1
    set app_service ""
    # Set up flag-related work.
    array set flags {
        -fields       { [array set fields  [iapp_pull $ptr args]] }
        -route_domain { [set route_domain  [iapp_pull $ptr args]] }
        -port         { [set port_override [iapp_pull $ptr args]] }
        -aaa_domain   { [set aaa_domain    1] }
        -aaa_pool     { [set aaa_priority  0] }
        -noapp        { [set app_service " app-service none"] }
    }
    iapp_process_flags flags args

    # Identify the non-address/non-port fields. These go inside braces in tmsh.
    set nonport_fields [lsearch -all -not -inline -regexp \
        [array names fields] {address|port|port-secure}]

    set members ""
    foreach row [join $args] {

        # Skip invalid table rows.
        if { [llength [join $row]] %2 == 1 } {
            continue
        }

        # Import APL table into an array for processing.
        array unset columns
        array set columns [join $row]
        set addr $columns($fields(address))

        # Identify the port number, either from table columns or by -port flag.
        if { $port_override != -1 } {
            set port $port_override
        } elseif { [info exists columns($fields(port))] } {
            set port $columns($fields(port))
        } elseif { [info exists columns($fields(port-secure))] } {
            set port $columns($fields(port-secure))
        } else {
            set port 80
        }

        # If specified, strip entered route domain and append the flag value.
        if { $route_domain != "" } {
            set addr [lindex [split $addr "%"] 0]
            set addr "$addr%$route_domain"
        }

        # If -aaa_domain, use domain controller format, otherwise use pool format
        if { $aaa_domain } {
            append members " $columns($fields(host)) \{ ip $addr $app_service \}"
        } else {
            append members " [iapp_destination $addr $port] \{"

            # Transfer non-port fields from the table to the tmsh string.
            foreach name $nonport_fields {
                if { [info exists columns($fields($name))] } {
                    append members " $name $columns($fields($name))"
                }
            }

            # If -aaa_pool, add priority field with incrementing value.
            # This is required by APM.
            if { $aaa_priority >= 0 } {
                append members " priority-group [incr aaa_priority]$app_service"
            }
            append members " \}"
        }
    }

    return "[expr { $aaa_domain ? "" : "members " }][expr { $members eq "" \
        ? "none" : "replace-all-with \{ $members \}" }]"
}

proc iapp_debug { args } {

    # Passwords should be obscured in all logs. Fields shown here are handled
    # in this proc, but the global variable may be overwritten if alternate
    # fields should be obscured.
    if { ![info exists ::SENSITIVES] } {
        set ::SENSITIVES {
            account-password
            admin-encrypted-password
            bind-pw
            PASSWORD
            password
            passwd
            proxy-ca-passphrase
            secret
        }
    }

    # look for any of the sensitive words, and replace the word that follows it
    set regex "(\\m([join $::SENSITIVES |])\\M)\\s+\[^\\s\]*"
    regsub -all $regex [join $args] {\1 -OBSCURED-} args
    regsub -all "(<Password.*>).*(</Password>)" $args {\1-OBSCURED-\2} args

    set lev [tmsh::get_field_value [lindex [tmsh::get_config sys scriptd \
        log-level] 0] log-level]
    if { $lev eq {debug} } {
        puts $args
    }
}

# The apm_config proc provides a tmsh pre-processor for APM
# configuration, which in most cases will drastically reduce
# implementation code. To configure APM with this proc, pass
# it an array of object names and associated meta-tag substitutions.
# Each object must be categorized as a profile, a resource, or
# a policy-item. APM agents and customization-groups are derived
# from these 3 categories as needed.
#
# apm_config's return value is a list of the APM profiles defined
# in the argument and instantiated by the proc. This allows the
# procedure call to be embedded directly into a virtual server
# definition.
#
# These universal meta-tags may be placed anywhere in the array:
# <ITEM> The object name, eg. apm_access
# <PREFIX> The app name, including folder, eg. /Common/my_app.app/my_app
#
# Profile objects require the following meta-tags:
# <PROFILE_TYPE> The tmsh object type, eg. "apm profile access"
# <PROFILE_DEF>  The body of the object, eg.:
#     "access-policy <PREFIX>
#      defaults-from /Common/access
#      eps-group <PREFIX>_eps
#      errormap-group <PREFIX>_errormap
#      general-ui-group <PREFIX>_general_ui"
#
# apm_config will automatically create default customization-groups
# for the "-group" lines specified in access profile definitions.
# In the above example, there is no need to additionally specify a
# customization-group for errormap and general-ui.
#
# <PROFILE_TYPE> is a catch-all for other APM types, eg:
#      apm_sso {
#          <PROFILE_TYPE> {apm sso kerberos}
#          <PROFILE_DEF>  "account-name <USER>
#                          account-password <PASS>
#                          realm <REALM>" }
#
# In the example above, <PROFILE_TYPE> and <PROFILE_DEF> are
# apm_config meta-tags, while <USER>, <PASS>, and <REALM> must
# be substituted before calling apm_config, eg. if these tags are
# defined in $pre_proc_map, they may be substituted with:
# array set apm_map [string map [subst $pre_proc_map] [array get apm_map]]
#
# Resource objects require the following meta-tags:
# <RESOURCE_TYPE> The apm resource object type, eg. "webtop"
# <RESOURCE_DEF>  The body of the object, eg.:
#     "customization-group <ITEM>
#      minimize-to-tray false
#      webtop-type full"
#
# In the above example, a customization-group is specified. Any
# customization-group is assumed to be blank unless further defined by the
# <GROUP_DEF> meta-tag, eg. <GROUP_DEF> {type webtop}
#
# Policy-item objects are defined by the following meta-tags:
# <AGENT_TYPE>   default "resource-assign"
# <AGENT_DEF>    default "customization-group <ITEM>"
# <ITEM_AGENT>   default "agents { <ITEM>_ag { type <AGENT_TYPE> }}"
# <ITEM_CAPTION> default "<ITEM>"
# <ITEM_COLOR>   default "1"
# <ITEM_TYPE>    default "action"
# <ITEM_RULES>   defaults to a set of expressions/next-items where specified
# <RULE_CAPTION_0> default "fallback"
# <RULE_CAPTION_1> default "Successful"
# <RULE_CAPTION_2> default "successful"
#
# apm_config generates the APM agent and customization-group definitions
# as required for each policy-item, but specific objects may be defined
# by using the <AGENT_DEF> and <GROUP_DEF> meta-tags.
# To suppress the formation of an APM agent, specify <ITEM_AGENT> {}.

proc iapp_apm_config { args } {

    set app_service ""
    array set flags  {
        -noapp       { [set app_service "app-service none\n   "] }
    }
    iapp_process_flags flags args

    upvar [lindex $args 0] map_array

    # Pull $prefix from the array
    set prefix $map_array(prefix)
    unset map_array(prefix)

    # Stencils for creating apm objects
    set access_form \
       "<TMSH_CREATE> apm policy access-policy <ITEM> {\n   \
          $app_service    caption general\n   \
          start-item <ACCESS_START_ITEM>\n   \
          default-ending <ACCESS_ENDING>\n   \
          items replace-all-with {\n<ACCESS_ITEMS>    }\n}"

    set profile_form "<TMSH_CREATE> <PROFILE_TYPE> <ITEM> {\n   \
        $app_service    <PROFILE_DEF>\n}"

    set resource_form "<TMSH_CREATE> apm resource <RESOURCE_TYPE> <ITEM> {\n   \
        $app_service    <RESOURCE_DEF>\n}"

    set agent_form "<TMSH_CREATE> apm policy agent <AGENT_TYPE> <ITEM>_ag {\n   \
        $app_service    <AGENT_DEF>\n}"

    set group_form "<TMSH_CREATE> apm policy customization-group <ITEM> {\
        $app_service    <GROUP_DEF>}"

    set agent_group_form "<TMSH_CREATE> apm policy customization-group <ITEM>_ag {\
        $app_service    <GROUP_DEF>}"

    set policy_item_form "<TMSH_CREATE> apm policy policy-item <ITEM> {
    $app_service    <ITEM_AGENT>caption <ITEM_CAPTION>
    color <ITEM_COLOR>
    <ITEM_TYPE>
    <ITEM_RULES>\n}"

    # 1st round apm string map
    set default_map_1 {
        <ACCESS_ITEM> {}
        <AGENT_DEF> "customization-group <ITEM>_ag"
        <ITEM_AGENT> "agents replace-all-with {
        <ITEM>_ag { type <AGENT_TYPE> }}\n    "
        <ITEM_CAPTION> <ITEM>
        <ITEM_COLOR> {1}
        <ITEM_TYPE> "item-type action"
        <ITEM_RULES> "rules
        {[expr {[string first <RULE_NEXT_2> $map_array($item)] != -1 ? "{
            caption <RULE_CAPTION_2>
            expression <RULE_EXPR_2>
            next-item ${prefix}_<RULE_NEXT_2>
        }":""}][expr {[string first <RULE_NEXT_1> $map_array($item)] != -1 ? "{
            caption <RULE_CAPTION_1>
            expression <RULE_EXPR_1>
            next-item ${prefix}_<RULE_NEXT_1>
        }":""}]{
            caption <RULE_CAPTION_0>
            next-item ${prefix}_<RULE_NEXT_0>
        }}"
    }

    # 2nd round apm string map
    set default_map_2 {
        <ITEM> [expr { $item eq {default} ? "$prefix" : "${prefix}_$item" }]
        <PREFIX> $prefix
        <LOCAL_PATH> [string map {/ :} $prefix]
        <GROUP_DEF> ""
        <AGENT_TYPE> "resource-assign"
        <RULE_CAPTION_2> "successful"
        <RULE_CAPTION_1> "Successful"
        <RULE_CAPTION_0> "fallback"
    }

    # Build APM access profile and access-policy from the access_form.
    # Tags <ACCESS_ITEM> and <ACCESS_ENDING> are picked up from
    # $map_array items. <ITEM> and <GROUP_DEF> are picked up from
    # $default_map_2.
    foreach item [lsort [array names map_array]] {

        # Pick up the <ACCESS_ENDING> tag. There should be just 1.
        set access_form [string map $map_array($item) $access_form]

        # Filter out items that do not belong in the access-policy.
        # Anything with an ITEM_xxx tag belongs
        if { [string first <ITEM_ $map_array($item)] == -1 } {
            continue
        }

        # Add to the items list for the access-policy, e.g. priority
        append access_items "        ${prefix}_$item {<ACCESS_ITEM>}\n"
        set access_items [string map $map_array($item) $access_items]
        set access_items [string map [subst $default_map_1] $access_items]
    }

    # Build APM resources, policy-items, agents, and customization-groups from
    # the policy_item_form and resource_form.
    foreach item [lsort [array names map_array]] {

        # Each item starts as a profile, a resource, or a policy-item.
        # Profiles are free-form, so other apm objects can use the profile form.
        # In most cases, a policy-item spawns an agent.
        # Any definition specifying a customization-group will spawn that group.
        if { [string first "<PROFILE_DEF>" $map_array($item)] != -1 } {

            # Collect profile names for attachment to the virtual server
            if { [string first "apm profile " $map_array($item)] != -1 } {
                lappend profiles [expr { $item eq {default}
                                 ? "$prefix" : "${prefix}_$item" }]
                # When an access profile is found, built a policy of the same name
                if { [string first "apm profile access" $map_array($item)] != -1 } {
                    set def [string map "<ACCESS_ITEMS> {$access_items}" $access_form]
                    append cmds "[string map [subst $default_map_2] $def]\n"
                }
            }
            set def $profile_form
        } elseif { [string first "<RESOURCE_DEF>" $map_array($item)] != -1 } {
            set def $resource_form
        } else {
            set def $policy_item_form
            if { [string first "<ITEM_AGENT> {}" $map_array($item)] == -1 } {
                append def $agent_form
            }
        }

        # Apply 1st pass of string maps
        set def [string map $map_array($item) $def]
        set def [string map [subst $default_map_1] $def]

        # If a customization-group is specified, add its definition
        if { [string first "customization-group" $def] != -1 } {
            if { [string first "apm policy agent" $def] != -1 } {
                append def $agent_group_form
            } elseif { [string first "apm profile access" $def] == -1 } {
                append def $group_form
            }
        }

        # Apply 2nd pass of string maps
        set def [string map $map_array($item) $def]
        append cmds [string map [subst $default_map_2] $def]
    }

    # Divide and execute tmsh commands
    set tag "<TMSH_CREATE>"
    set tag_length [string length $tag]
    set last [expr { [string first $tag $cmds] + $tag_length }]
    while { [set pos [string first $tag $cmds $last]] != -1 } {
        incr pos -1
        iapp_conf create [string range $cmds $last $pos]
        set last [expr { $pos + $tag_length + 1 }]
    }
    iapp_conf create [string range $cmds $last end]
    return $profiles
}

proc iapp_upgrade_template { upgrade_var upgrade_trans } {
    upvar $upgrade_var   upgrade_var_arr
    upvar $upgrade_trans upgrade_trans_arr

    # create the new variables from the old
    foreach { var } [array names upgrade_var_arr] {

        # substitute old variable name for abbreviation "##"
        regsub -all {##} $upgrade_var_arr($var) \$$var map_cmd

        # run the mapping command from inside the array
        if { [catch { subst $map_cmd } err] } {
            if { [string first "no such variable" $err] == -1 } {
                puts "ERROR $err"
            }
        }
    }

    # move variables over and apply translations
    set var_mods ""
    set var_adds ""
    foreach var [array names vx] {

        # if the APL variable name is in the translation array,
        # then use the custom translation built for that variable.
        if { [info exists upgrade_trans_arr($var)] } {
            array set sub_arr [subst $upgrade_trans_arr($var)]
            if { [info exists sub_arr($vx($var))] } {
                set vx($var) $sub_arr($vx($var))
            }
            array unset sub_arr
        # else, if the APL variable value is in the translation array,
        # then use the generic translation of that value.
        } elseif { [info exists upgrade_trans_arr($vx($var))] } {
            set vx($var) [subst $upgrade_trans_arr($vx($var))]
        }

        # add to tmsh command string
        if { [info exists ::$var] } {
            append var_mods "\n $var \{ value \"$vx($var)\" \} "
        } else {
            append var_adds "\n $var \{ value \"$vx($var)\" \} "
        }
    }

    # move tables over
    set tbl_mods ""
    set tbl_adds ""
    foreach tbl [array names tx] {

        # convert table from APL format to TMSH format
        if { ![llength $tx($tbl)] } {
            set tbl_def "column-names none"
        } else {
            set rows_def ""
            foreach apl_row $tx($tbl) {
                array set row_arr [join $apl_row]
                append rows_def "\n  \{ row \{ "
                foreach apl_col [array names row_arr] {
                    append rows_def "$row_arr($apl_col) "
                }
                append rows_def "\}\}"
            }
            set tbl_def \
            "\n  column-names \{ [array names row_arr] \} rows \{ $rows_def \}"
            array unset row_arr
        }

        # add to tmsh command string
        if { [info exists ::$tbl] } {
            append tbl_mods "\n $tbl \{ $tbl_def \} "
        } else {
            append tbl_adds "\n $tbl \{ $tbl_def \} "
        }
    }

    # construct the "tmsh modify" command
    set cmd "sys application service $tmsh::app_name "
    if { [llength $var_mods] } {
        append cmd "\nvariables modify { $var_mods }"
    }
    if { [llength $var_adds] } {
        append cmd "\nvariables add { $var_adds }"
    }
    if { [llength $tbl_mods] } {
        append cmd "\ntables modify { $tbl_mods }"
    }
    if { [llength $tbl_adds] } {
        append cmd "\ntables add { $tbl_adds }"
    }

    # Execute with debug output. This conversion takes place within the
    # existing ASO, so tmsh modify is used instead of tmsh create.
    iapp_debug "TEMPLATE UPGRADE"
    iapp_conf modify $cmd
    return
}

proc iapp_downgrade_template { pivot_var upgrade_var downgrade_table } {
    upvar $downgrade_table downgrade_tbl_arr

    # The ASO variable "offload_history" is used to recover the legacy
    # choice a user made about SSL offload. It should be present in all cases.
    # This conditional only handles the case where a user has deliberately
    # deleted it by manipulating the ASO directly from tmsh.
    if { ![info exists ::offload_history] } {
        set ::offload_history "No"
    }

    # BIG-IP erases table contents when the APL optional hides the table.
    # Since the prior data is not available, this downgrade must back-convert
    # existing table data. Unlike tables, variables remain intact from the
    # legacy ASO.
    set tbl_def ""
    foreach tbl [array names downgrade_tbl_arr] {
        # Check for existence of each table in the current context.
        # If not, skip to next.
        if { ![info exists [set tbl]] } {
            continue
        }
        # Check for existence of each table in the legacy context.
        # If not, add an empty table so "tmsh tables modify" does not fail.
        if { ![info exists ::$downgrade_tbl_arr($tbl)] } {
            iapp_conf modify sys app ser $tmsh::app_name tables add \{ $downgrade_tbl_arr($tbl) \}
        }
        append tbl_def "$downgrade_tbl_arr($tbl) \{ "
        if { [llength [subst $$tbl]] } {
            set rows_def ""
            foreach apl_row [subst $$tbl] {
                array set row_arr [join $apl_row]
                append rows_def "\n  \{ row \{ "
                foreach apl_col [array names row_arr] {
                    append rows_def "$row_arr($apl_col) "
                }
                append rows_def "\}\}"
            }
            append tbl_def \
            "column-names \{ [array names row_arr] \} rows \{ $rows_def \}"
            array unset row_arr
        } else {
            append tbl_def "rows none"
        }
        append tbl_def " \} "
    }
    regsub -all "\n" $tbl_def {} tbl_def
    set cmd "sys app ser $tmsh::app_name \
        variables modify \{ \
            $pivot_var \{ value $::offload_history \} \
            $upgrade_var \{ value No \} \
        \} \
        tables modify \{ $tbl_def \}"
    iapp_debug "TEMPLATE DOWNGRADE"
    iapp_conf modify $cmd
    return
}

proc iapp_get_ca_certs { args } {
    # Procedure formats and returns ca-bundle 509 certificates from ca-bundle.bak
    # (copy of tmos supplied ca-bundle.crt)
    # Returns backup files when using -files flag
    # Returns specified restore file certificates when using -restore -return flags
    # Returns specified restore file table certificates when using -restore -tablename
    # Returns selected certificates
    #
    # Set defaults. Flag actions may overwrite defaults later.
    set rest_files         0
    set do_restore         0
    set restore_return     0
    set restore_table_name 0
    set do_certs 0
    set user_get [iapp_get_user]
    set username [string range $user_get [expr {[string last user $user_get] +5 }] end-3 ]
    # Set up flag-based actions.
    array set flags  {
        -files     { [set rest_files 1] }
        -return    { [set do_restore 1] [set restore_return 1] }
        -tablename { [set do_restore 1] [set restore_table_name 1] }
        -certs     { [set do_certs 1] }
    }
    iapp_process_flags flags args
    set fn_ca_bundle "[lindex $args 0]"
    set cert_choices "[lindex $args 1]"
    set duplicate " "
    if { $rest_files eq 0 || $do_restore } {
        set fh_ca_bundle [open $fn_ca_bundle r]
        set ca_bundle_data [read $fh_ca_bundle]
        close $fh_ca_bundle
        set ca_bundle_split [split [string map "{-----END CERTIFICATE-----} \001" $ca_bundle_data] "\001"]
        set final ""
        # Grab Subject Name and Serial number from each certificate
        foreach subject $ca_bundle_split {
            if {$subject eq {}} {
                continue
            }
            set a [string first Subject: $subject]
            set b [string first \n $subject $a]
            set ab [string range $subject $a $b]
            set c [expr {[string first O= $ab] +2}]
            if { $c < 2 }{
                set c [expr {[string first CN= $ab] +2}]
            }
            set d [expr {[string first , $ab $c] -1}]
            # Deal with case were comma is not present after subject name
            if { $d < 0 }{
                set dc [string range $ab $c end-1]
            # Deal with case were text is not able to be located using common name, just grab the first 30 characters
            } elseif { $d > 2000 }{
                set dc [string range $ab $c 47]
            } else {
                set dc [string range $ab $c $d]
            }
            set f [expr {[string first Number: $subject] +7}]
            set g [expr {[string first Signature $subject $f] -1}]
            set fg [string range $subject $f $g]
            # Remove spaces and new line characters from serial number
            set fg_nospace [string map {" " "" "\n" "" ":" ""} $fg]
            set first_5 [string map {"(" ""} [string range $fg_nospace 0 4]]
            # -cert flag returns list of selected root certificates
            if { $do_certs }{
                foreach selection $cert_choices {
                    if { $first_5 eq $selection }{
                        # setup to remove duplicate root certificates - tmos supplied ca-bundle can have duplicates
                        set i 0
                        set duplicate_split [split [string map "{ } \001" $duplicate] "\001"]
                        foreach dup $duplicate_split {
                            if { $dup eq $first_5 }{
                                incr i
                            }
                        }
                        # add certificate if not a duplicate
                        if { $i < 1 }{
                            append final "${subject}-----END CERTIFICATE-----\n"
                            puts [tmsh::log notice "User:'${username}' Modified CA-Bundle, adding the following Root CA:(SN) ${fg_nospace} Name:${dc}"]
                            append duplicate "$first_5 "
                        }
                    }
                }
            } elseif { $dc !="" || $fg_nospace !="" || $restore_table_name eq 1 }{
                if { $restore_return eq 0 && $restore_table_name eq 0 }{
                    append final "${dc},SN:${fg_nospace}\t${first_5}\n"
                } elseif { $restore_table_name eq 1 }{
                    set table_cert [string first ### $subject]
                    if { $table_cert > -1 && $table_cert < 500 } {
                        set ending "$subject-----END CERTIFICATE-----"
                        set table_certificate [string range $ending [string first -----BEGIN $ending] [ expr { [string first -----END $ending] +24 }]]
                        append final  "{ row { \"[string map {"\n" " "} $table_certificate]\" \"[string range $subject 4 [expr { [string first \n $subject 1] -1 }]]\" } }"
                    }

                } else {
                    set table_cert [string first ### $subject]
                    if { $table_cert < 0 || $table_cert > 500 } {
                        append final "${first_5} "
                    }
                }
            }
        }
        if { $do_restore && $restore_table_name eq 0 }{
            set final [string map {"(" ""} $final]
        }
        return $final
    }
    if { $rest_files }{
        # Pull TMOS ca-bundle file into list
        catch { set fn_bak_ca_bundle [exec ls -t /config/ssl/ssl.crt/] } err
        if { $::errorCode != "" } {
            puts "Error during file lookup in ssl certificate directory: ${err}"
            error "Error during file lookup in ssl certificate directory: ${err}"
        }
        foreach bak [join "$fn_bak_ca_bundle"] {
            set full_path "/config/ssl/ssl.crt/$bak"
            if { [iapp_is full_path $fn_ca_bundle] }{
                set fn_bak_exists 1
                break
            } else {
                set fn_bak_exists 0
            }
        }
        if { $fn_bak_exists }{
            puts "Backup of factory TMOS ca-bundle /config/ssl/ssl.crt/ca-bundle.crt, at:${fn_ca_bundle}, already exists. No need to backup"
        } elseif { $fn_bak_exists eq 0 }{
            puts "Backing up factory TMOS ca-bundle /config/ssl/ssl.crt/ca-bundle.crt, to ${fn_ca_bundle}."
            catch { exec cp /config/ssl/ssl.crt/ca-bundle.crt ${fn_ca_bundle} } err
            if { $::errorCode != "" } {
                puts "Error creating backup file:${fn_ca_bundle}: ${err}"
                error "Error creating backup file:${fn_ca_bundle}: ${err}"
            }
        }
        set restore_list [lsearch -all -inline $fn_bak_ca_bundle *_bak*]
        set restore_final ""
        foreach res $restore_list {
            append restore_final "${res}\t${res}\n"
        }
        if { $restore_final == "" }{
            return "No restore files found"
        } else {
            return $restore_final
        }
    }
}
    app-service none
    description none
    ignore-verification false
    script-checksum none
    script-signature none
    signing-key none
}
sys application template /Common/ise_dot1x_v0.1 {
    actions {
        definition {
            html-help {
            }
            implementation {
                package require iapp 1.0.0
tmsh::include f5.iapp.1.5.2.cli
iapp_template start

#################################################################
# This configuration is heavily based on this article:  
# https://community.cisco.com/t5/security-documents/how-to-cisco-amp-f5-deployment-guide-ise-load-balancing-using/ta-p/3631159#toc-hId--1235153972"
################################################################

# assign app name that user typed in as a variable
set app $tmsh::app_name

#set partition "Common"
#set aso "/$partition/${app}.app/$app"
#set app_service "${app}.app/${app}"

#set uri             $::main__sf_uri
set is_admin        [iapp_get_user -is_admin]
set tmos_v          [iapp_tmos_version]

## all "puts" statements log iapp execution stuff to /var/tmp/scriptd.out
#puts "Executing ${app} iApp intouch - ${cdate}"
## tmsh::log statements log to /var/log/ltm
#tmsh::log "Executing ${app} iApp intouch - ${cdate}"


################################################
### radius LB config portion
################################################

# define radius persist irule for universal persistence profile
set radius_mac_persist_irule {
# ISE persistence iRule based on Calling-Station-Id (MAC Address) with fallback to NAS-IP-Address as persistence identifier

when CLIENT_DATA {
    # 0: No Debug Logging  1: Debug Logging
    set debug 1
    # Persist timeout (seconds)
    set nas_port_type [RADIUS::avp 61 "integer"]
    if {$nas_port_type equals "19"}{
    set persist_ttl 29000
    if {$debug} {set access_media "Wireless"}
    } else {
    set persist_ttl 173000
    if {$debug} {set access_media "Wired"}
    }
    # If MAC address is present - use it as persistent identifier
    # See Radius AV Pair documentation on https://devcentral.f5.com/wiki/irules.RADIUS__avp.ashx
    if {[RADIUS::avp 31] ne "" }{
        set mac [RADIUS::avp 31 "string"]
        # Normalize MAC address to upper case
        set mac_up [string toupper $mac]
        persist uie $mac_up $persist_ttl
        if {$debug} {
        set target [persist lookup uie $mac_up] 
        log local0.alert "Username=[RADIUS::avp 1] MAC=$mac Normal MAC=$mac_up MEDIA=$access_media TARGET=$target"
        }
    } else {
        set nas_ip [RADIUS::avp 4 ip4]
        persist uie $nas_ip $persist_ttl
        if {$debug} {
        set target [persist lookup uie $nas_ip]
        log local0.alert "No MAC Address found - Using NAS IP as persist id. Username=[RADIUS::avp 1] NAS IP=$nas_ip MEDIA=$access_media TARGET=$target"
        }
    }
}
}

# create radius persist irule
#  no variable sustitutions on this irule
set radius_mac_persist_irule [iapp::conf create ltm rule ${app}_radius_mac_persist_irule $radius_mac_persist_irule]

# create a default radiusLB profile
set radius_profile [iapp::conf create ltm profile radius ${app}_radiusLB_profile \
    defaults-from /Common/radiusLB]

# create udp profile for virtual servers
set radius_udp_profile [iapp_conf create ltm profile udp ${app}_radius_udp_profile \
    datagram-load-balancing enabled \
    defaults-from udp \
    idle-timeout 60 \
    ip-df-mode clear \
    no-checksum disabled ]

# create universal persistence profile for radius sticky irule
set radius_uni_persist [iapp::conf create ltm persistence universal ${app}_radius_uni_persist \
    faults-from universal \
    match-across-services enabled \
    rule $radius_mac_persist_irule \
    timeout 300 ]

set 0_pool_monitor [iapp::conf create ltm monitor radius ${app}_radius1812_monitor \
    debug no \
    defaults-from /Common/radius \
    destination *:1812 \
    username $main__muser \
    password $main__mpass \
    secret $main__mpsk \
    interval 10 \
    timeout 31 \
    time-until-up 0 ]

set 0_pool [iapp::conf create ltm pool ${app}_0_pool \
    load-balancing-mode least-connections-node \
    [iapp::pool_members -port 0 $main__servers] \
    monitor $0_pool_monitor \
    service-down-action reselect ]

set 1645_vs [iapp::conf create ltm virtual ${app}_radius_u1645_vs \
    ip-protocol udp \
    destination $main__vip:1645 \
    persist replace-all-with \{ $radius_uni_persist \{ default yes \} \} \
    profiles replace-all-with \{ $radius_profile $radius_udp_profile \} \
    pool $0_pool ]

set 1646_vs [iapp::conf create ltm virtual ${app}_radius_u1646_vs \
    ip-protocol udp \
    destination $main__vip:1646 \
    persist replace-all-with \{ $radius_uni_persist \{ default yes \} \} \
    profiles replace-all-with \{ $radius_profile $radius_udp_profile \} \
    pool $0_pool ]

set 1812_vs [iapp::conf create ltm virtual ${app}_radius_u1812_vs \
    ip-protocol udp \
    destination $main__vip:1812 \
    persist replace-all-with \{ $radius_uni_persist \{ default yes \} \} \
    profiles replace-all-with \{ $radius_profile $radius_udp_profile \} \
    pool $0_pool ]

set 1813_vs [iapp::conf create ltm virtual ${app}_radius_u1813_vs \
    ip-protocol udp \
    destination $main__vip:1813 \
    persist replace-all-with \{ $radius_uni_persist \{ default yes \} \} \
    profiles replace-all-with \{ $radius_profile $radius_udp_profile \} \
    pool $0_pool ]


##############################################################
###  outbound u1700 snats
##############################################################
#  Potential TODO: enable VS only on the vlan the server is on
#  This would require sorting through the vlans/IPs to find the network
#  the servers are on, which could be difficult
#  Documenting as an RFE for when/if it's needed
#############################################################

# create outbound snat pool with vip as member
set snat_pool [iapp::conf create ltm snatpool ${app}_udp1700_out_snatpool \
    pool members replace-all-with \{ $main__vip \} ]

set snat_fastl4 [iapp::conf create ltm profile fastl4 ${app}_fastl4 \
    defaults-from /Common/fastL4 \
    loose-initialization enabled \
    reset-on-timeout disabled \
    software-syn-cookie disabled ]

# extract ip addresses from pool information gathered from gui (APL)
set members [regexp -all -inline {(?:\d+\.){3}\d+} $main__servers]

# loop through list of pool members and create snat forwarders for each
foreach item $members {
    iapp::conf create ltm virtual ${app}_${item}_u1700_snatOut_vs \
        source ${item}/32 \
        destination any:1700 \
        ip-forward \
        ip-protocol udp \
        profiles replace-all-with \{ $snat_fastl4 \} \
        source-address-translation \{ type snat pool ${snat_pool} \}
    }


##############################################################
###  dhcp relay config
##############################################################

### create dhcp persist irule 
set dhcp_mac_persist_irule {
# iRule dhcp_mac_sticky
#
# Original google lookup dhcp_mac_sticky rev 0.5 (2016/05/23)
timing off
when CLIENT_ACCEPTED priority 100 {
# Rule Name and Version shown in the log
set RULE_NAME "DHCP MAC Sticky"
set RULE_ID "dhcp_mac_sticky"
# 0: No Debug Logging 1: Debug Logging
set debug 1
# Persist timeout (seconds)
set persist_ttl 3600
# Using High-Speed Logging in thie rule
set log_prefix "\[$RULE_ID\]([IP::client_addr])"
set log_prefix_d "$log_prefix\(debug\)"
if {$debug}{log local0.debug "$log_prefix_d ***** iRule: $RULE_NAME executed *****"}
if { [UDP::payload length] < 200 } {
    log local0.info "$log_prefix Ignored due to length\(less than 200 octet\)"
    drop
    return
}
else {
    # BOOTP
    binary scan [UDP::payload] ccccH8SB1xa4a4a4a4H2H2H2H2H2H2 \
    msg_type hw_type hw_len hops transaction_id seconds\
    bootp_flags client_ip_hex your_ip_hex server_ip_hex \
    relay_ip_hex m(a) m(b) m(c) m(d) m(e) m(f)
    # Put client address into variables for session key
    set your_ip [IP::addr $your_ip_hex mask 255.255.255.255]
    set client_mac "$m(a):$m(b):$m(c):$m(d):$m(e):$m(f)"
    binary scan [UDP::payload] H32H64H128H8 \
    padding server_host_name boot_file magic_cookie
    if {$debug}{log local0.debug "$log_prefix_d BOOTP: $your_ip $client_mac"}
    # DHCP
    binary scan [UDP::payload] x240H* dhcp_option_payload
    set option_hex 0
    set options_length [expr {([UDP::payload length] -240) * 2 }]
    for {set i 0} {$i < $options_length} {incr i [expr { $length * 2 + 2 }]} {
        # extract option value and convert into decimal
        # for human readability
        binary scan $dhcp_option_payload x[expr $i]a2 option_hex
        set option [expr 0x$option_hex]
        # move index to get length field
        incr i 2
        # extract length value and convert length from Hex string to decimal
        binary scan $dhcp_option_payload x[expr $i]a2 length_hex
        set length [expr 0x$length_hex]
        # extract value field in hexadecimal format
        binary scan $dhcp_option_payload x[expr $i + 2]a[expr { $length * 2 }] value_hex
        switch $option {
            61 {
                # Client Identifier
                # This option is used by DHCP clients to specify their unique
                # identifier. DHCP servers use this value to index their database of
                # address bindings. This value is expected to be unique for all
                # clients in an administrative domain.
                #
                binary scan $value_hex a2a* ht id
                switch $ht {
                    01 {
                        binary scan $id a2a2a2a2a2a2 m(a) m(b) m(c) m(d) m(e) m(f)
                        # Normalize MAC address to upper case
                        set value [string toupper "$m(a)-$m(b)-$m(c)-$m(d)-$m(e)-$m(f)"]
                    }
                    default {
                        set value "$id"
                    }
                }
                persist uie $value $persist_ttl
                if {$debug}{log local0.debug "$log_prefix_d ***** iRule: $RULE_NAME completed ***** OPTION61=$value TARGET=[persist lookup uie $value]"}
            }
        }
    }
}
}
}

# create dhcp persist irule
set dhcp_mac_persist_irule [iapp::conf create ltm rule ${app}_dhcp_mac_persist_irule $dhcp_mac_persist_irule]

# create universal persistence profile for dhcp persistence irule
set dhcp_uni_persist [iapp::conf create ltm persistence universal ${app}_dhcp_uni_persist \
    faults-from universal \
    match-across-services enabled \
    rule $dhcp_mac_persist_irule \
    timeout 300 ]

set dhcp_relay [iapp_conf create ltm virtual ${app}_dhcp_relay_u67_vs \
    ip-protocol udp \
    destination $main__vip:67 \
    fallback-persistence source_addr \
    persist replace-all-with \{ $dhcp_uni_persist \{ default yes \} \} \
    profiles replace-all-with \{ $radius_udp_profile \} \
    pool $0_pool ]

## end dhcp config
#############################################################

iapp_template stop
            }
            macro {
            }
            presentation {
                section options {
    choice display_help display "xlarge" default "hide"
    optional ( options.display_help == "full" ) { message display_help_max }
}

section intro {
    message hello
    optional ( options.display_help == "full" ) { 
        message exec_summ
        message additional_info
        message additional_info2
    }
}

section main {
    # remove some defaults for final iapp version

    string vip display "xlarge" required validator "IpAddress"
    optional ( options.display_help == "full" ) { message vip_extra }
    string muser display "xlarge" required
    optional ( options.display_help == "full" ) { message muser_extra }
    string mpass display "xlarge" required
    string mpsk display "xlarge" required

    table servers {
        string addr required validator "IpAddress" display "xlarge"
    }
}

section todo {
    message what
    optional ( options.display_help == "full" ) {
        message todo1
        message todo2
        message todo3
    }
}

section about {
    message about
    optional ( options.display_help == "full" ) {
        message creation
        message v1
    }
}

text {
    options "Template Options"
    options.display_help "Additional information?" {
         "Yes" => "full",
         "No" => "hide"
    }

    options.display_help_max "" "Inline help is available to provide contextual descriptions to aid in the completion of this configuration.  Select to show or hide the inline help in this template. Important notes and warnings are always visible, no matter which selection you make here."

    intro "ISE Dot1X iApp"
    intro.hello "Introduction" "This template is used to deploy Cisco ISE Dot1x configuration to support wired and wireless clients"
    intro.exec_summ "iApp Naming" "Explain some sort of naming standard?"
    intro.additional_info "" "There should can only be one deployment of this iapp per F5 pair since this does not allow the option to select an existing pool"

    main "Deployment Details"
    main.vip "VIP"
    main.vip_extra "" "This is the frontside VIP that clients will connect to.  It is also what the servers will get snat'd to for udp/1700 outbound"
    main.muser "RADIUS Monitor User"
    main.muser_extra "" "RADIUS user for ISE health monitor"
    main.mpass "RADIUS Monitor Password"
    main.mpsk "RADIUS Monitor PreSharedKey"
    main.servers "RADIUS Servers"

    todo "TODO/Options list"
    todo.what "" "List of 'to do/options' items so they can be tracked and prioritized - Show inline help for more details"
    todo.todo1 "todo 1" "Add option to select existing pool"
    todo.todo2 "todo 2" "Add option to select vlan to enable outbound snat forwarder on - should only be needed to further lock down the traffic the forwarder catches"
    todo.todo3 "todo 3" "Add ISE server name field to be collected with ISE server IP - could be important for naming/standardization down the road"

    about "About"
    about.about "" "Show inline help for more information"
    about.creation "" "This iApp was developed during Nov. 2019 by Ben Gordon (b.gordon@f5.com) on TMOS v14.1.0.6."
    about.v1 "v0.1" "Initial version"
}
            }
            role-acl none
            run-as none
        }
    }
    description none
    ignore-verification false
    requires-bigip-version-max none
    requires-bigip-version-min 14.1
    requires-modules { ltm }
    signing-key none
    tmpl-checksum none
    tmpl-signature none
}
